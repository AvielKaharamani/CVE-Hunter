import json
from data_classes import LibraryCves, PackageFileType


class Helper:
    @staticmethod
    def check_pre_release_version(version: str) -> bool:
        """
        Function checks if the version is pre-released version
        :param version: The version we check
        :return: whether the version is pre-released or not
        """
        return any(c.isalpha() for c in version)

    @staticmethod
    def check_version_existing(version: str, library_versions: list[str]) -> bool:
        """
        Function checks if the library version exists or not
        :param version: The version we check
        :param library_versions: All the available versions
        :return: whether the version exists or not
        """
        for v in library_versions:
            if version == v:
                return True

        return False

    @staticmethod
    def parse_affected_versions(library: str, library_versions: list[str], version: str, cve_data: dict) -> list[str]:
        """
        Function extracts all CVE affected library versions
        :param library: The library we check
        :param library_versions: All the library available versions
        :param version: The current library version we check
        :param cve_data: The CVE information
        :return: List of CVE affected library versions
        """
        affected_versions = []
        empty = '*'

        try:
            nodes = cve_data['result']['CVE_Items'][0]['configurations']['nodes']
        except KeyError:
            raise RuntimeError(f'{library} {version}, CVE data structure is not supported')

        for node in nodes:
            for cpe_match in node['cpe_match']:
                cpe_info = cpe_match['cpe23Uri'].split(':')
                cpe_library = cpe_info[4]
                cpe_library_version = cpe_info[5]

                if cpe_library.lower() == library.lower():
                    begin_version, end_version = Helper.find_versions_key(cpe_match)

                    if begin_version in cpe_match and end_version in cpe_match:
                        start = library_versions.index(cpe_match[begin_version])
                        end = library_versions.index(cpe_match[end_version]) + 1
                        affected_versions.extend(library_versions[start:end])
                    elif cpe_library_version != empty:
                        affected_versions.append(cpe_info[5])
                    else:
                        raise RuntimeError(f'{library} {version}, CVE data structure is not supported')

        return affected_versions

    @staticmethod
    def find_versions_key(cpe_match: dict) -> tuple[str, str]:
        """
        Function finds the key of the start and end versions that the CVE is affecting
        :param cpe_match: The cpe data
        :return: The key of the first and the last version the CVE is affecting
        """
        begin_version = end_version = ''

        for key in cpe_match.keys():
            if key.startswith('versionStart'):
                begin_version = key
            if key.startswith('versionEnd'):
                end_version = key

        return begin_version, end_version

    @staticmethod
    def find_closest_fix_version(curr_version: str, library_versions: list[str], affected_versions: list[str]) -> str:
        """
        Function finds the closest fix version for a certain CVE
        :param curr_version: The current version of the library
        :param library_versions: The available versions of the library
        :param affected_versions: Library affected versions by the CVE
        :return: The closest fix version for the CVE in the library
        """
        start_index = library_versions.index(curr_version)
        for version in library_versions[start_index:]:
            if version not in affected_versions and not Helper.check_pre_release_version(version):
                return version

        return 'None'

    @staticmethod
    def parse_file(file_data: str, package_type: PackageFileType) -> list[LibraryCves]:
        """
        Function reads from the input package and parses the library and its version
        :param file_data: The file information in a string format
        :param package_type: The input package type
        :return: List of libraries and their versions
        """
        libraries = []
        if package_type == PackageFileType.REQUIREMENTS_TEXT:
            for line in file_data.split('\n'):
                library_info = line.strip().split('==')
                if len(library_info) != 2:
                    continue
                libraries.append(LibraryCves(library_info[0], library_info[1]))
        elif package_type == PackageFileType.PACKAGE_JSON:
            data = json.loads(file_data)
            dependencies = data['dependencies']
            for library, version in dependencies.items():
                libraries.append(LibraryCves(library, version[1:]))

        return libraries

    @staticmethod
    def print_result_table(results) -> None:
        """
        Function prints the results of the CVE search in a table
        :param results: The dict with the information about the libraries, versions, CVEs - description and version fix
        """
        print("{:<20}{:<30}{:<20}{:<15}{:<25}"
              .format('Dependency Name', 'Current Dependency Version', 'CVE ID', 'Fix version', 'CVE description'))

        for library in results:
            print(library)
