from typing import Generator
from data_classes import LibraryCves


class Helper:
    @staticmethod
    def check_pre_release_version(version: str) -> bool:
        """
        Function checks if the version is pre-released version
        :param version: The version we check
        :return: whether the version is pre-released or not
        """
        return any(c.isalpha() for c in version)

    @staticmethod
    def check_version_existing(version: str, library_versions: list[str]) -> bool:
        """
        Function checks if the library version exists or not
        :param version: The version we check
        :param library_versions: All the available versions
        :return: whether the version exists or not
        """
        for v in library_versions:
            if version == v:
                return True

        return False

    @staticmethod
    def parse_affected_versions(library: str, library_versions: list[str], version: str, cve_data: dict) -> list[str]:
        """
        Function extracts all CVE affected library versions
        :param library: The library we check
        :param library_versions: All the library available versions
        :param version: The current library version we check
        :param cve_data: The CVE information
        :return: List of CVE affected library versions
        """
        affected_versions = []
        begin_version = 'versionStartIncluding'
        end_version = 'versionEndExcluding'
        empty = '*'

        try:
            nodes = cve_data['result']['CVE_Items'][0]['configurations']['nodes']
        except KeyError:
            raise RuntimeError(f'{library} {version}, CVE data structure is not supported')

        for node in nodes:
            for cpe_match in node['cpe_match']:
                cpe_info = cpe_match['cpe23Uri'].split(':')
                cpe_library = cpe_info[4]
                cpe_library_version = cpe_info[5]

                if cpe_library.lower() == library.lower():
                    if begin_version in cpe_match and end_version in cpe_match:
                        start = library_versions.index(cpe_match[begin_version])
                        end = library_versions.index(cpe_match[end_version]) + 1
                        affected_versions.extend(library_versions[start:end])
                    elif cpe_library_version != empty:
                        affected_versions.append(cpe_info[5])
                    else:
                        raise RuntimeError(f'{library} {version}, CVE data structure is not supported')

        return affected_versions

    @staticmethod
    def find_closest_fix_version(curr_version: str, library_versions: list[str], affected_versions: list[str]) -> str:
        """
        Function finds the closest fix version for a certain CVE
        :param curr_version: The current version of the library
        :param library_versions: The available versions of the library
        :param affected_versions: Library affected versions by the CVE
        :return: The closest fix version for the CVE in the library
        """
        start_index = library_versions.index(curr_version)
        for version in library_versions[start_index:]:
            if version not in affected_versions and not Helper.check_pre_release_version(version):
                return version

        return 'None'

    @staticmethod
    def print_result_table(results: Generator[LibraryCves]) -> None:
        """
        Function prints the results of the CVE search in a table
        :param results: The dict with the information about the libraries, versions, CVEs - description and version fix
        """
        print("{:<20}{:<30}{:<20}{:<15}{:<25}"
              .format('Dependency Name', 'Current Dependency Version', 'CVE ID', 'Fix version', 'CVE description'))

        for library in results:
            print(library)
