import configparser
import requests
from helper import Helper
from data_classes import Cve, LibraryCves, PackageFileType

config = configparser.ConfigParser()
config.read('config.ini')

NVD_CVE_BASE_URL = config.get('DEFAULT', 'nvd_cve_base_url')
NVD_CVES_BASE_URL = config.get('DEFAULT', 'nvd_cves_base_url')
PYPI_BASE_URL = config.get('DEFAULT', 'pypi_base_url')
NPMJS_BASE_URL = config.get('DEFAULT', 'npmjs_base_url')


class DataRetriever:
    @staticmethod
    def send_request(url: str) -> dict:
        """
        Function sends a get request and retrieves the json data
        :param url: The url we are requesting data from
        :return: The data from the url
        """
        response = requests.get(url)

        if not response.ok:
            raise RuntimeError(f'GET request to: {url}, was unsuccessful, Check library name')

        return response.json()

    @staticmethod
    def extract_cves_info(cves_id: list[str], library: str, version: str, library_versions: list[str]) -> tuple:
        """
        Function extracts description and library fix versions about a certain CVEs
        :param cves_id: The IDs of the CVEs we search for description
        :param library: The library we check
        :param version: The version of the library we check
        :param library_versions: The available versions of the library
        :return: List of CVE descriptions, List of fix versions for the CVEs
        """
        cves_id_filtered = []
        cves_description = []
        library_fix_versions = []
        for cve_id in cves_id:
            url = f'{NVD_CVE_BASE_URL}/{cve_id}'
            cve_data = DataRetriever.send_request(url)

            affected_versions = Helper.parse_affected_versions(library, library_versions, version, cve_data)

            if version not in affected_versions:  # Check if the library is not affected by the CVE
                continue

            cves_id_filtered.append(cve_id)

            try:
                description = cve_data['result']['CVE_Items'][0]['cve']['description']['description_data'][0]['value']
            except KeyError:
                description = 'None'

            cves_description.append(description)

            fix_version = Helper.find_closest_fix_version(version, library_versions, affected_versions)
            library_fix_versions.append(fix_version)

        return cves_id_filtered, cves_description, library_fix_versions

    @staticmethod
    def extract_cves(library: str, version: str, package_type: PackageFileType) -> LibraryCves:
        """
        Function extracts CVEs in the certain library in a certain version from NVD
        :param library: The library we search
        :param version: The version of the library
        :param package_type: npm/python package type
        :return: CVEs results we gathered from the NVD database aligned in a dict
        """
        # Search for CVEs that reference the library and version
        query = f'{library} {version} cve'
        url = f'{NVD_CVES_BASE_URL}?keyword={query}'

        library_versions = DataRetriever.extract_library_versions(library, package_type)

        if not Helper.check_version_existing(version, library_versions):
            raise RuntimeError(f'{library} has no such version: {version}')

        data = DataRetriever.send_request(url)
        # print(url)
        # print(data)

        cves_id = [result['cve']['CVE_data_meta']['ID'] for result in data['result']['CVE_Items']]

        cves_id_filtered, cve_descriptions, fix_versions = DataRetriever.extract_cves_info(
            cves_id, library, version, library_versions)

        cve_dict = {cve_id: Cve(description, fix_version)
                    for cve_id, description, fix_version in zip(cves_id_filtered, cve_descriptions, fix_versions)}

        return LibraryCves(library, version, cve_dict)

    @staticmethod
    def extract_library_versions(library: str, package_type: PackageFileType) -> list[str]:
        """
        Function extracts all library versions of a python/nmp library
        :param library: The library we search
        :param package_type: The type of the input package
        :return: List of versions of the library
        """
        versions = []
        if package_type == PackageFileType.REQUIREMENTS_TEXT:
            versions = DataRetriever.extract_python_library_versions(library)
        elif package_type == PackageFileType.PACKAGE_JSON:
            versions = DataRetriever.extract_npm_library_versions(library)

        def version_key(version):
            return tuple(map(int, version.split('.')))

        filtered_versions = list(filter(lambda x: not Helper.check_pre_release_version(x), versions))
        return sorted(filtered_versions, key=version_key)

    @staticmethod
    def extract_python_library_versions(library: str) -> list[str]:
        """
        Function extracts all library versions using PyPI REST API
        :param library: The library we search
        :return: List of versions of the library
        """
        url = f'{PYPI_BASE_URL}/{library}/json'
        data = DataRetriever.send_request(url)

        return list(data['releases'].keys())

    @staticmethod
    def extract_npm_library_versions(library: str) -> list[str]:
        """
        Function extracts all library versions using npm REST API
        :param library: The library we search
        :return: List of versions of the library
        """
        url = f'{NPMJS_BASE_URL}/{library}'
        data = DataRetriever.send_request(url)

        return data['versions'].keys()
